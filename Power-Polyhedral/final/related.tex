%\todo{Needs work to make sense}
\subsection{Benchmarks for Polyhedral Framework}
%\subsection{Benchmarks for Polyhedral Framework and Auto-parallelization}
There are a few benchmarks available to evaluate polyhedral transformations as 
an approach to improving application performance.  Our work adds two non-trivial application (LULESH and \emph{brdr2d})
to the family of benchmarks that are polyhedral optimizable. Polybench\cite{Polybench} and 
SWIM\cite{SWIM} benchmark are two benchmark suites that are often used. The Polybench programs evaluate polyhedral 
transformations and are used to construct predictive models by Park {\it et al.}\cite{EJ2011,EJ2012, EJ2013}.
They are also used to evaluate auto-parallelization techniques targeting different architectures,
using different tools. Grauer-Gray {\it et al.}\cite{Scott} utilized high level languages 
to target GPU architecture by annotating Polybench programs. Konstantinidis {\it et al.}\cite{LCPC2013}
studied GPU code generation given the Polybench programs that contain affine loops. 
SCoPs in LULESH and \emph{brdr2d} are much complex than polybench programs. 
In particular, some LULESH SCoPs contain thousands of dependencies. The  
two benchmarks can be used to evaluate the effectiveness of newly-developed polyhedral techniques. 
%\subsection{Performance/Energy Measurement and Tuning}
\subsection{Energy Measurement and Tuning}
The accuracy of our energy-aware polyhedral framework relies on the exactness
of RAPL. While presenting the HAECER framework for short-term energy measurements 
using RAPL, H\"{a}hnel {\it et al.} reported the identical
curve characteristics comparing RAPL with external measurement\cite{RAPL-Related}.
The HAECER framework was not used here because of the need to measure long code
paths--the executions finish in the order of seconds by testing with large datasets.

Our work is not the first to show that ``hurry up to quit'' can be most energy
efficient. Yuki {\it et al.} developed a high-level energy model of power consumption
under Dynamic Voltage and Frequency Scaling (DVFS) and found it best to run
as fast as possible to completion\cite{SpeedEnergy}. They pointed out that the 
constant power of current machines were significant enough to render DVFS useless in saving energies.
Before them, Cho and Melhem\cite{Cho} identified that DVFS might not help if the fraction
of total power unaffected by DVFS is large.
We evaluated the energy effects of polyhedral optimizations, rather than DVFS,
by measuring the energy consumptions of hundreds to thousands of program variants.
In most cases, programs trying to ``hurry up to finish'' consumed minimum
amount of energy and that optimizing for execution can be used as a proxy to optimizing for energy.

Rahman {\it et al.}\cite{CF12} studied the impact of application level optimizations from both the 
performance and power efficiency perspective of various applications. They found
that optimizing for performance did not guarantee better power consumption. We 
observed similar results in Figure~\ref{fig:TE} and Figure~\ref{fig:2mm-TE} for non-optimal
program variants but the graphs showed that for the optimal case, tuning for performance and power were 
effectively equivalent. To improve performance and energy efficiency for a Many-Core architecture,
Garcia {\it et al.}\cite{Garcia} studied the energy consumptions of applications and proposed models 
characterizing application energy consumption footprints. We did not
develop energy models but took advantage of the exposed hardware interfaces to obtain accurate   
energy consumption information from modern commodity processor architectures like
Intel Sandy Bridge and Xeon Phi.

To improve performance, people have 
developed techniques from distinctive ways. Tavarageri {\it et al.}\cite{Reduce-Cache} 
adopted compiler analysis approach to configure the cache size to reduce energy consumption
without performance loss. New programming languages\cite{IPDPS13:LULESH} and 
models like Chapel, Liszt and others were introduced to facilitate program optimizations
on parallel architectures.
