Reducing application energy consumption is important to improve user experience of 
embedded systems, e.g. smart phones, GPS navigators etc.  
However applications (kernels) are not energy-aware in its design stage. Tuning
for energy efficiency is necessary to meet the system's energy constraints.
Tiwari et al. performed coarse-grain measurement and provided evidence for the 
existence of opportunities to auto-tune for energy in parallel applications\cite{Tiwari:EnergyAutoTune}.
Existing Polyhedral auto-tuning frameworks have shown promising results in tuning for execution
for small computation kernels like the Polybench programs\cite{EJ2012}. 
In this work we use the framework added with fine-grained energy measurement support to enable tuning for energy.
We choose 6 representative Polybench kernels (from linear-algebra, machine learning, and stencils code) 
and tune them on two architectures (Intel SandyBridge and Intel MIC).
When tuning the application for better energy usage, some combination of loop optimizations, including loop 
tiling, loop unrolling, and loop fusion, are performed on kernels along with the auto-parallelization.
We observed for dense matrix kernels, \emph{the optimization that has the minimum execution time 
did not consume the least amount of energy}. This differs from previous observations \cite{Wang2014}.
We also found that the optimizations that work best on one architecture do not carry to another.  
 
This paper has three main contributions: 
(1) Introducing the energy-aware framework for energy auto-tuning
(2) Observing that it is \emph{not} always the case to be able to reduce energy consumption by reducing execution time.
(3) Evaluation of architectural differences of energy behaviors corresponding to the same loop transformations.

%The rest of the paper is organized as follows. In Section~\ref{sec:tools}, we describe the tools
%used to measure energy consumptions. Section~\ref{sec:benchmarks} describes the benchmarks used for  
%measuring the energy consumptions. Experimental results and analysis are presented in Section~\ref{sec:results}. Section~\ref{sec:conclusion} has our conclusions.
%
